# Learn Golang [Channels](Channels.md)

# Worker Pool (Thread Pool)

Bài này mình giới thiệu thêm một khả năng chứng minh <mark style="background: #ADCCFFA6;">sức mạnh của Golang</mark> và khiến mình thích thú hơn với ngôn ngữ đầy rẫy kí hiệu * & này. Đó là về worker pool.

Nói qua về Worker Pool, qua tên gọi ta có thể hình dung được <mark style="background: #BBFABBA6;">công dụng của nó là tạo ra một nơi chứa gọi là pool, để chứa các worker của chúng ta</mark>. <mark style="background: #FFB86CA6;">Mục đích là để ta có thể quản lý các worker, quản lý việc phân phối task và đặc biệt là kiểm soát được những tài nguyên dùng chung giữa các worker</mark>. <mark style="background: #D2B3FFA6;">Ví dụ như các worker chạy đồng thời và cùng truy xuất vào 1 file hoặc dùng chung một API.</mark>


![[worker_pool_example_1.png]]
Việc xây dựng một worker pool trong Go dễ dàng được thực hiện bởi dùng Channel và ta chỉ cần vài dòng code là đủ rồi cho một ví dụ đơn giản rồi

```
package main

import (
	"fmt"
	"time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Println("worker", id, "processing job", j)
		time.Sleep(time.Second)
		results <- j * 2
	}
}

func main() {
	jobs := make(chan int, 100)
	results := make(chan int, 100)

	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	for j := 1; j <= 9; j++ {
		jobs <- j
	}
	close(jobs)

	for a := 1; a <= 9; a++ {
		<-results
	}
}

```


Trong ví dụ trên, có 3 worker được start và có 9 work item (9 job) được đẩy vào jobs channel. Mỗi worker sẽ bốc một jobs ra xử lý lệnh Println và đẩy kết quả vào results channel.
# Xây dựng một worker pool hoàn chỉnh

Đặt tất cả những code ta mới dùng trong ví dụ bên nhau. Thay vì jobs channel chỉ để chứa 1 kiểu dữ liệu đơn giản là int thì giờ ta xây dựng 1 model task, để chứa các task truyền qua channel tới worker.

```
import (
	"sync"
)


type Pool struct {
	Tasks []*Task

	concurrency int
	tasksChan   chan *Task
	wg          sync.WaitGroup
}


func NewPool(tasks []*Task, concurrency int) *Pool {
	return &Pool{
		Tasks:       tasks,
		concurrency: concurrency,
		tasksChan:   make(chan *Task),
	}
}


func (p *Pool) Run() {
	for i := 0; i < p.concurrency; i++ {
		go p.work()
	}

	p.wg.Add(len(p.Tasks))
	for _, task := range p.Tasks {
		p.tasksChan <- task
	}


	close(p.tasksChan)

	p.wg.Wait()
}


func (p *Pool) work() {
	for task := range p.tasksChan {
		task.Run(&p.wg)
	}
}

```

Vậy là xong, ta có thể chạy thử nó trong file main.go như sau

```
tasks := []*Task{
    NewTask(func() error { return nil }),
    NewTask(func() error { return nil }),
    NewTask(func() error { return nil }),
}

p := pool.NewPool(tasks, conf.Concurrency)
p.Run()

var numErrors int
for _, task := range p.Tasks {
    if task.Err != nil {
        log.Error(task.Err)
        numErrors++
    }
    if numErrors >= 10 {
        log.Error("Too many errors.")
        break
    }
}

```